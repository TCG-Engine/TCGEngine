<?php

include './Core/HTTPLibraries.php';

$response = new stdClass();
// If CheckLoggedInUserMod exists (web environment), use it; allow CLI runs otherwise
if(function_exists('CheckLoggedInUserMod')) {
  $error = CheckLoggedInUserMod();
  if($error !== "") {
    $response->error = $error;
    echo json_encode($response);
    exit();
  }
}

$rootName = TryGET("rootName", "");
// If running from CLI, accept args like rootName=RBSim or the first positional arg
if($rootName == "" && php_sapi_name() == 'cli') {
  global $argv;
  for($i=1; $i<count($argv); ++$i) {
    if(strpos($argv[$i], 'rootName=') === 0) {
      $rootName = substr($argv[$i], strlen('rootName='));
      break;
    }
  }
  if($rootName == '' && isset($argv[1])) $rootName = $argv[1];
}

$schemaFile = "./Schemas/" . $rootName . "/TurnSchema.txt";

if(!file_exists($schemaFile)) {
  $response->error = "Turn schema not found: " . $schemaFile;
  echo json_encode($response);
  exit();
}

$handler = fopen($schemaFile, 'r');
$states = []; // array of state objects: {id, abbr, code, transitions: [{input, target}]}

$currentState = null;

while(!feof($handler)) {
  $line = fgets($handler);
  if($line === false) break;
  $line = trim($line);
  if($line == "") continue;
  // If line contains ";" it's a state header: Title; Abbr; Code
  if(strpos($line, ';') !== false) {
    $parts = array_map('trim', explode(';', $line));
    $title = $parts[0];
    $abbr = isset($parts[1]) ? $parts[1] : $title;
    $code = isset($parts[2]) ? $parts[2] : $abbr;
    $currentState = new stdClass();
    $currentState->Title = $title;
    $currentState->Abbr = $abbr;
    $currentState->Code = $code;
    $currentState->Transitions = [];
    $states[$abbr] = $currentState;
    continue;
  }
  // Otherwise it's a transition line of the form: INPUT -> TARGET
  $arr = preg_split('/->|â†’/', $line);
  if(count($arr) >= 2 && $currentState != null) {
    $input = trim($arr[0]);
    $target = trim($arr[1]);
    // allow target abbreviations or full names; normalize to abbreviation if possible
    $t = $target;
    $currentState->Transitions[] = (object)[ 'Input' => $input, 'Target' => $t ];
  }
}

fclose($handler);

// Ensure output folder exists
$rootPath = './' . $rootName;
if(!is_dir($rootPath)) mkdir($rootPath, 0755, true);

// Write TurnStates.php
$statesFile = $rootPath . '/TurnStates.php';
$h = fopen($statesFile, 'w');
fwrite($h, "<?php\n");
fwrite($h, "// Auto-generated by zzTurnGenerator.php\n");
fwrite($h, "// Generated turn states and transitions\n\n");
fwrite($h, "\$turnStates = array();\n");

// Build a states array in PHP code
fwrite($h, "\$turnStates = array(\n");
foreach($states as $abbr => $st) {
  $titleSafe = addslashes($st->Title);
  $codeSafe = addslashes($st->Code);
  fwrite($h, "  '" . $abbr . "' => array(\n");
  fwrite($h, "    'Title' => '" . $titleSafe . "',\n");
  fwrite($h, "    'Code' => '" . $codeSafe . "',\n");
  fwrite($h, "    'Transitions' => array(\n");
  foreach($st->Transitions as $tr) {
    $in = addslashes($tr->Input);
    $tgt = addslashes($tr->Target);
    fwrite($h, "      array('Input' => '" . $in . "', 'Target' => '" . $tgt . "'),\n");
  }
  fwrite($h, "    ),\n");
  fwrite($h, "  ),\n");
}
fwrite($h, ");\n\n");

fclose($h);

// Write TurnController.php
$ctrlFile = $rootPath . '/TurnController.php';
$h = fopen($ctrlFile, 'w');
fwrite($h, "<?php\n");
fwrite($h, "// Auto-generated turn controller by zzTurnGenerator.php\n\n");
fwrite($h, "include_once __DIR__ . '/TurnStates.php';\n\n");

// Emit a phase-based EvaluateTransition that uses the global $gCurrentPhase
fwrite($h, "function EvaluateTransition(\$input) {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  if(!isset(\$gCurrentPhase)) return \$gCurrentPhase;\n");
fwrite($h, "  switch(\$gCurrentPhase) {\n");
// For each state, emit case block checking that state's transitions
foreach($states as $abbr => $st) {
  fwrite($h, "    case '" . addslashes($abbr) . "':\n");
  // Exact-match transitions first
  foreach($st->Transitions as $tr) {
    $in = strtoupper(trim($tr->Input));
    $tgt = addslashes($tr->Target);
    fwrite($h, "      if(strtoupper(trim(\$input)) == '" . addslashes($in) . "') return '" . $tgt . "';\n");
  }
  // AUTO fallback for this state (first AUTO transition)
  $autoTarget = null;
  foreach($st->Transitions as $tr) { if(strtoupper(trim($tr->Input)) == 'AUTO') { $autoTarget = $tr->Target; break; } }
  if($autoTarget !== null) fwrite($h, "      // AUTO fallback\n      return '" . addslashes($autoTarget) . "';\n");
  // PASS fallback for this state
  $passTarget = null;
  foreach($st->Transitions as $tr) { if(strtoupper(trim($tr->Input)) == 'PASS') { $passTarget = $tr->Target; break; } }
  if($passTarget !== null) fwrite($h, "      // PASS fallback\n      return '" . addslashes($passTarget) . "';\n");
  fwrite($h, "      break;\n");
}
fwrite($h, "    default: break;\n");
fwrite($h, "  }\n");
fwrite($h, "  return \$gCurrentPhase;\n");
fwrite($h, "}\n\n");

// AdvanceTurnState now operates on global $gCurrentPhase
fwrite($h, "function AdvanceTurnState(\$input) {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  \$next = EvaluateTransition(\$input);\n");
fwrite($h, "  if(\$next !== \$gCurrentPhase) { \$gCurrentPhase = \$next; return true; }\n");
fwrite($h, "  return false;\n");
fwrite($h, "}\n\n");

// Auto-advance along AUTO transitions until none remain. Returns true if state changed.
fwrite($h, "function AutoAdvance() {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  \$changed = false;\n");
fwrite($h, "  while(true) {\n");
fwrite($h, "    // Use EvaluateTransition('AUTO') to determine the next auto target for the current phase.\n");
fwrite($h, "    \$next = EvaluateTransition('AUTO');\n");
fwrite($h, "    if(\$next === \$gCurrentPhase) break;\n");
fwrite($h, "    \$gCurrentPhase = \$next;\n");
fwrite($h, "    ExecutePhase();\n");
fwrite($h, "    \$changed = true;\n");
fwrite($h, "  }\n");
fwrite($h, "  return \$changed;\n");
fwrite($h, "}\n\n");

// Emit ExecutePhase and convenience helpers that advance+execute or auto-advance+execute
fwrite($h, "// Execute the current phase's code using a switch-based registry for performance.\n");
fwrite($h, "function ExecutePhase() {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  if(!isset(\$gCurrentPhase)) return false;\n");
fwrite($h, "  switch(\$gCurrentPhase) {\n");
foreach($states as $abbr => $st) {
  $codeName = addslashes($st->Code);
  fwrite($h, "    case '" . addslashes($abbr) . "':\n");
  if($codeName !== '') {
    fwrite($h, "      if(function_exists('" . $codeName . "')) { " . $codeName . "(); }\n");
  }
  fwrite($h, "      break;\n");
}
fwrite($h, "    default: break;\n");
fwrite($h, "  }\n");
fwrite($h, "  // Optional persistence hook that user code can implement to persist the current phase.\n");
fwrite($h, "  if(function_exists('PersistCurrentPhase')) { PersistCurrentPhase(\$gCurrentPhase); }\n");
fwrite($h, "  return true;\n");
fwrite($h, "}\n\n");

fwrite($h, "// Advance by input and execute the new phase if it changed. Returns true if changed.\n");
fwrite($h, "function AdvanceAndExecute(\$input) {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  \$changed = AdvanceTurnState(\$input);\n");
fwrite($h, "  if(\$changed) ExecutePhase();\n");
fwrite($h, "  return \$changed;\n");
fwrite($h, "}\n\n");

fwrite($h, "// Auto-advance along AUTO transitions and execute final phase if changed.\n");
fwrite($h, "function AutoAdvanceAndExecute() {\n");
fwrite($h, "  global \$gCurrentPhase;\n");
fwrite($h, "  \$changed = AutoAdvance();\n");
fwrite($h, "  return \$changed;\n");
fwrite($h, "}\n\n");

fclose($h);

$response->ok = true;
$response->statesFile = $statesFile;
$response->controllerFile = $ctrlFile;

echo json_encode($response);

?>